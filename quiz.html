<!DOCTYPE html>
<html lang="ms">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kuiz Asma'ul Husna</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Amiri:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="assets/css/quiz.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>Kuiz Asma'ul Husna</h1>
            <p class="subtitle">Padankan Nama Allah dengan Maknanya</p>
        </header>

        <div class="progress-info">
            <div class="progress-text">
                <span id="currentQuestion">Soalan 1-10</span> dari 50
            </div>
            <div class="score">
                Skor: <span id="score">0</span>/<span id="totalAnswered">0</span>
            </div>
        </div>

        <div id="quizArea" class="quiz-area">
            <div class="stopwatch" id="stopwatch">0:00</div>
            <!-- Quiz questions will be loaded here -->
        </div>

        <div class="buttons">
            <button class="submit-btn" id="submitBtn">Semak Jawapan</button>
            <button class="next-btn hidden" id="nextBtn">Soalan Seterusnya</button>
            <button class="home-btn" id="homeBtn">Kembali</button>
        </div>

        <div class="feedback" id="feedback">
            <!-- Feedback will be shown here -->
        </div>
    </div>

    <script>
        let allNames = [];
        let currentRound = 0;
        let totalScore = 0;
        let totalAnswered = 0;
        let currentQuestions = [];
        let userAnswers = {};

        // Load names from JSON
        async function loadNames() {
            try {
                const response = await fetch('data/names.json');
                const data = await response.json();
                allNames = data.names;
                startNewRound();
            } catch (error) {
                console.error('Error loading names:', error);
                alert('Error loading quiz data. Please refresh the page.');
            }
        }

        // Shuffle array
        function shuffle(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // Get random questions
        function getRandomQuestions() {
            const shuffled = shuffle(allNames);
            return shuffled.slice(0, 10);
        }

        // Start new round
        function startNewRound() {
            currentRound++;
            userAnswers = {};
            dropZoneAnswerData.clear(); // Clear stored answer data
            currentQuestions = getRandomQuestions();

            // Shuffle Arabic names but keep them paired with their translations
            const shuffledQuestions = shuffle(currentQuestions);

            renderQuiz(shuffledQuestions, []);
            updateProgress();
            startStopwatch();

            document.getElementById('submitBtn').classList.remove('hidden');
            document.getElementById('submitBtn').disabled = false;
            document.getElementById('nextBtn').classList.add('hidden');
            document.getElementById('feedback').classList.remove('show');
        }

        // Render quiz
        function renderQuiz(questions, meanings) {
            const quizArea = document.getElementById('quizArea');
            // Keep stopwatch, remove everything else
            const stopwatch = document.getElementById('stopwatch');
            quizArea.innerHTML = '';
            quizArea.appendChild(stopwatch);

            // Create Arabic name buttons (draggable answers) in 2×5 grid
            const arabicContainer = document.createElement('div');
            arabicContainer.className = 'arabic-names-grid';

            questions.forEach((question, index) => {
                const arabicBtn = document.createElement('div');
                arabicBtn.className = 'arabic-button';
                arabicBtn.textContent = question.arabic;
                arabicBtn.draggable = true;
                arabicBtn.dataset.questionId = question.id;
                arabicBtn.dataset.arabic = question.arabic;
                arabicBtn.dataset.correctMeaning = question.malay;
                arabicBtn.dataset.index = index;

                // Alternate between golden and silver styles
                if (index < 5) {
                    arabicBtn.classList.add('golden');
                } else {
                    arabicBtn.classList.add('silver');
                }

                // Drag events
                arabicBtn.addEventListener('dragstart', handleDragStart);
                arabicBtn.addEventListener('dragend', handleDragEnd);

                // Touch events for mobile
                arabicBtn.addEventListener('touchstart', handleTouchStart);
                arabicBtn.addEventListener('touchcancel', handleTouchCancel);

                arabicContainer.appendChild(arabicBtn);
            });

            quizArea.appendChild(arabicContainer);

            // Create translation items (static questions) with drop zones
            const translationsContainer = document.createElement('div');
            translationsContainer.className = 'translations-container';

            // Create two columns
            const leftColumn = document.createElement('div');
            leftColumn.className = 'translation-column';
            const rightColumn = document.createElement('div');
            rightColumn.className = 'translation-column';

            questions.forEach((question, index) => {
                const translationItem = document.createElement('div');
                translationItem.className = 'translation-item';

                // Drop zone on the left
                const dropZone = document.createElement('div');
                dropZone.className = 'drop-zone';
                dropZone.dataset.questionId = question.id;
                dropZone.dataset.correctArabic = question.arabic;
                dropZone.dataset.correctMeaning = question.malay;
                dropZone.dataset.index = index;
                dropZone.textContent = ''; // Empty initially

                // Translation text on the right (remove "Yang" prefix)
                const translationText = document.createElement('div');
                translationText.className = 'translation-text';
                const malayText = question.malay.startsWith('Yang ') 
                    ? question.malay.substring(5) 
                    : question.malay;
                translationText.textContent = malayText;

                // Drop zone events
                dropZone.addEventListener('dragover', handleDragOver);
                dropZone.addEventListener('dragleave', handleDragLeave);
                dropZone.addEventListener('drop', handleDrop);
                dropZone.addEventListener('touchmove', handleTouchMove);
                dropZone.addEventListener('touchend', handleTouchEnd);
                
                // Click/touch handler for undo functionality
                dropZone.addEventListener('click', handleDropZoneClick);
                
                // Track touch for undo on filled zones
                let touchStartPosForUndo = null;
                dropZone.addEventListener('touchstart', (e) => {
                    if (dropZone.classList.contains('filled') && !touchElement && !draggedElement) {
                        touchStartPosForUndo = {
                            x: e.touches[0].clientX,
                            y: e.touches[0].clientY,
                            time: Date.now()
                        };
                    }
                }, {passive: true});
                
                dropZone.addEventListener('touchend', (e) => {
                    if (dropZone.classList.contains('filled') && 
                        !touchElement && 
                        !draggedElement && 
                        touchStartPosForUndo) {
                        const touch = e.changedTouches[0];
                        const deltaX = Math.abs(touch.clientX - touchStartPosForUndo.x);
                        const deltaY = Math.abs(touch.clientY - touchStartPosForUndo.y);
                        const deltaTime = Date.now() - touchStartPosForUndo.time;
                        
                        // Only undo if it was a tap (minimal movement, quick tap)
                        if (deltaX < 10 && deltaY < 10 && deltaTime < 300) {
                            e.preventDefault();
                            performUndo(dropZone);
                        }
                        touchStartPosForUndo = null;
                    }
                }, {passive: false});

                translationItem.appendChild(dropZone);
                translationItem.appendChild(translationText);

                // Distribute to columns (first 5 in left, last 5 in right)
                if (index < 5) {
                    leftColumn.appendChild(translationItem);
                } else {
                    rightColumn.appendChild(translationItem);
                }
            });

            translationsContainer.appendChild(leftColumn);
            translationsContainer.appendChild(rightColumn);
            quizArea.appendChild(translationsContainer);
        }

        // Drag and drop handlers
        let draggedElement = null;
        let touchElement = null;
        let touchStartPos = {};
        
        // Store references to drop zones and their answer element data
        let dropZoneAnswerData = new Map();

        function handleDragStart(e) {
            draggedElement = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', e.target.dataset.questionId);
            e.dataTransfer.setData('arabic', e.target.dataset.arabic);
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            e.target.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.target.classList.remove('drag-over');
        }

        // Helper function to restore an answer element to the grid
        function restoreAnswerToGrid(answerData) {
            const arabicContainer = document.querySelector('.arabic-names-grid');
            if (!arabicContainer) return;

            const arabicBtn = document.createElement('div');
            arabicBtn.className = 'arabic-button';
            arabicBtn.textContent = answerData.arabic;
            arabicBtn.draggable = true;
            arabicBtn.dataset.questionId = answerData.questionId;
            arabicBtn.dataset.arabic = answerData.arabic;
            arabicBtn.dataset.correctMeaning = answerData.correctMeaning;
            arabicBtn.dataset.index = answerData.index;

            // Apply the original style (golden or silver)
            if (answerData.index < 5) {
                arabicBtn.classList.add('golden');
            } else {
                arabicBtn.classList.add('silver');
            }

            // Reattach event listeners
            arabicBtn.addEventListener('dragstart', handleDragStart);
            arabicBtn.addEventListener('dragend', handleDragEnd);
            arabicBtn.addEventListener('touchstart', handleTouchStart);
            arabicBtn.addEventListener('touchcancel', handleTouchCancel);

            // Add to grid (append to end)
            arabicContainer.appendChild(arabicBtn);
        }

        // Helper function to store answer data in drop zone
        function storeAnswerInDropZone(dropZone, answerElement) {
            const answerData = {
                questionId: answerElement.dataset.questionId,
                arabic: answerElement.dataset.arabic,
                correctMeaning: answerElement.dataset.correctMeaning,
                index: answerElement.dataset.index
            };
            dropZoneAnswerData.set(dropZone, answerData);
        }

        // Helper function to return old answer from drop zone
        function returnOldAnswerFromDropZone(dropZone) {
            if (dropZone.classList.contains('filled') && dropZoneAnswerData.has(dropZone)) {
                const answerData = dropZoneAnswerData.get(dropZone);
                restoreAnswerToGrid(answerData);
                dropZoneAnswerData.delete(dropZone);
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drag-over');

            const draggedQuestionId = e.dataTransfer.getData('text/plain');
            const draggedArabic = e.dataTransfer.getData('arabic');
            const dropZoneQuestionId = e.target.dataset.questionId;

            if (e.target.classList.contains('drop-zone')) {
                const dropZone = e.target;
                
                // If drop zone is already filled, return the old answer first
                if (dropZone.classList.contains('filled')) {
                    returnOldAnswerFromDropZone(dropZone);
                    // Remove old user answer
                    delete userAnswers[dropZoneQuestionId];
                }

                // Display the transliteration or Arabic name in the drop zone
                const draggedBtn = draggedElement;
                const displayText = draggedBtn.textContent;
                dropZone.textContent = displayText;
                dropZone.classList.add('filled');
                dropZone.dataset.droppedArabic = draggedArabic;
                userAnswers[dropZoneQuestionId] = draggedQuestionId;

                // Store the answer data before removing the element
                if (draggedElement) {
                    storeAnswerInDropZone(dropZone, draggedElement);
                    draggedElement.remove();
                    draggedElement = null;
                }

                checkIfAllAnswered();
            }
        }

        // Handle click on drop zone to undo (mouse click)
        function handleDropZoneClick(e) {
            const dropZone = e.target;
            
            // Only handle if drop zone is filled
            if (!dropZone.classList.contains('drop-zone') || !dropZone.classList.contains('filled')) {
                return;
            }
            
            // Don't trigger if user is trying to drag/drop something
            if (touchElement || draggedElement) {
                return;
            }
            
            // For mouse clicks, perform undo immediately
            performUndo(dropZone);
        }
        
        function performUndo(dropZone) {
            // Return the answer to available choices
            returnOldAnswerFromDropZone(dropZone);
            
            // Clear the drop zone
            dropZone.textContent = '';
            dropZone.classList.remove('filled');
            dropZone.classList.remove('drag-over');
            delete dropZone.dataset.droppedArabic;
            
            // Remove from user answers
            const questionId = dropZone.dataset.questionId;
            delete userAnswers[questionId];
            
            checkIfAllAnswered();
        }

        // Touch handlers for mobile
        function handleTouchStart(e) {
            // If there's already a touch in progress, reset it first
            if (touchElement && touchElement !== e.target) {
                // Reset previous touch element
                touchElement.style.position = '';
                touchElement.style.zIndex = '';
                touchElement.style.left = '';
                touchElement.style.top = '';
                touchElement.classList.remove('dragging');
            }

            // Only allow dragging answer boxes, not drop zones
            if (!e.target.classList.contains('arabic-button')) {
                return;
            }

            touchElement = e.target;
            touchElement.classList.add('dragging');

            const touch = e.touches[0];
            touchStartPos = {
                x: touch.clientX,
                y: touch.clientY,
                elementX: touchElement.offsetLeft,
                elementY: touchElement.offsetTop
            };

            // Make element follow finger
            touchElement.style.position = 'fixed';
            touchElement.style.zIndex = '1000';
            touchElement.style.left = touch.clientX - 50 + 'px';
            touchElement.style.top = touch.clientY - 25 + 'px';
            
            e.preventDefault(); // Prevent default touch behavior
        }

        function handleTouchMove(e) {
            if (!touchElement) return;
            e.preventDefault();

            const touch = e.touches[0];
            touchElement.style.left = touch.clientX - 50 + 'px';
            touchElement.style.top = touch.clientY - 25 + 'px';

            // Highlight drop zone (can highlight filled zones too for replacement)
            const dropZones = document.querySelectorAll('.drop-zone');
            dropZones.forEach(zone => {
                const rect = zone.getBoundingClientRect();
                if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                    touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
                    zone.classList.add('drag-over');
                } else {
                    zone.classList.remove('drag-over');
                }
            });
        }

        function handleTouchCancel(e) {
            // Reset touch element if touch is cancelled
            if (touchElement) {
                touchElement.style.position = '';
                touchElement.style.zIndex = '';
                touchElement.style.left = '';
                touchElement.style.top = '';
                touchElement.classList.remove('dragging');
                
                // Clean up drag-over classes
                const dropZones = document.querySelectorAll('.drop-zone');
                dropZones.forEach(zone => {
                    zone.classList.remove('drag-over');
                });
                
                touchElement = null;
            }
        }

        function handleTouchEnd(e) {
            if (!touchElement) return;

            const touch = e.changedTouches[0];
            const dropZones = document.querySelectorAll('.drop-zone');

            let dropped = false;
            
            // Find the drop zone under the touch point
            for (const zone of dropZones) {
                const rect = zone.getBoundingClientRect();
                if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                    touch.clientY >= rect.top && touch.clientY <= rect.bottom) {

                    const draggedQuestionId = touchElement.dataset.questionId;
                    const draggedArabic = touchElement.dataset.arabic;
                    const displayText = touchElement.textContent;
                    const questionId = zone.dataset.questionId;

                    // Only drop if we haven't already dropped this element
                    if (!dropped) {
                        // If drop zone is already filled, return the old answer first
                        if (zone.classList.contains('filled')) {
                            returnOldAnswerFromDropZone(zone);
                            // Remove old user answer
                            delete userAnswers[questionId];
                        }

                        zone.textContent = displayText;
                        zone.classList.add('filled');
                        zone.classList.remove('drag-over');
                        zone.dataset.droppedArabic = draggedArabic;
                        userAnswers[questionId] = draggedQuestionId;

                        // Store the answer data before removing the element
                        storeAnswerInDropZone(zone, touchElement);
                        touchElement.remove();
                        dropped = true;
                    }
                    break; // Exit loop once we've found and handled the drop zone
                }
            }

            if (!dropped && touchElement) {
                // Reset position
                touchElement.style.position = '';
                touchElement.style.zIndex = '';
                touchElement.style.left = '';
                touchElement.style.top = '';
                touchElement.classList.remove('dragging');
            }

            // Clean up: remove drag-over class from all zones
            dropZones.forEach(zone => {
                zone.classList.remove('drag-over');
            });

            touchElement = null;
            checkIfAllAnswered();
        }

        // Check if all questions are answered
        function checkIfAllAnswered() {
            const submitBtn = document.getElementById('submitBtn');
            submitBtn.disabled = Object.keys(userAnswers).length !== currentQuestions.length;
        }

        // Submit answers
        function submitAnswers() {
            // Stop stopwatch and record time
            const elapsedTime = stopStopwatch();
            if (elapsedTime) {
                updateBestTime(elapsedTime);
            }

            let correctCount = 0;
            const feedbackDiv = document.getElementById('feedback');
            feedbackDiv.innerHTML = '<h2>Keputusan</h2>';

            currentQuestions.forEach((question) => {
                const userAnswerId = userAnswers[question.id];
                const isCorrect = userAnswerId && userAnswerId == question.id;

                if (isCorrect) correctCount++;

                const feedbackItem = document.createElement('div');
                feedbackItem.className = `feedback-item ${isCorrect ? 'correct' : 'incorrect'}`;

                const userAnswerText = userAnswerId ? 
                    (document.querySelector(`.arabic-button[data-question-id="${userAnswerId}"]`)?.textContent || 'Tiada jawapan') 
                    : 'Tiada jawapan';

                feedbackItem.innerHTML = `
                    <div class="arabic">${question.arabic}</div>
                    <div class="answer">
                        Jawapan anda: ${userAnswerText}
                        ${!isCorrect ? `<br><span class="correct-answer">Jawapan betul: ${question.transliteration || question.arabic}</span>` : ' ✓'}
                    </div>
                `;

                feedbackDiv.appendChild(feedbackItem);

                // Update drop zone styling
                const dropZones = document.querySelectorAll('.drop-zone');
                dropZones.forEach(zone => {
                    if (zone.dataset.questionId == question.id) {
                        zone.classList.add(isCorrect ? 'correct' : 'incorrect');
                    }
                });
            });

            totalScore += correctCount;
            totalAnswered += currentQuestions.length;

            updateScore();
            feedbackDiv.classList.add('show');

            document.getElementById('submitBtn').classList.add('hidden');
            document.getElementById('nextBtn').classList.remove('hidden');
        }

        // Update progress
        function updateProgress() {
            const start = (currentRound - 1) * 10 + 1;
            const end = Math.min(currentRound * 10, totalAnswered + 10);
            document.getElementById('currentQuestion').textContent = `Soalan ${start}-${end}`;
        }

        // Update score
        function updateScore() {
            document.getElementById('score').textContent = totalScore;
            document.getElementById('totalAnswered').textContent = totalAnswered;
        }

        // Event listeners
        document.getElementById('submitBtn').addEventListener('click', submitAnswers);
        document.getElementById('nextBtn').addEventListener('click', startNewRound);
        document.getElementById('homeBtn').addEventListener('click', () => {
            window.location.href = 'index.html';
        });

        // Stopwatch functionality
        let stopwatchInterval = null;
        let startTime = null;
        let elapsedSeconds = 0;

        function startStopwatch() {
            startTime = Date.now();
            elapsedSeconds = 0;
            const stopwatchEl = document.getElementById('stopwatch');
            if (stopwatchEl) stopwatchEl.textContent = '0:00';

            if (stopwatchInterval) clearInterval(stopwatchInterval);

            stopwatchInterval = setInterval(() => {
                elapsedSeconds++;
                const minutes = Math.floor(elapsedSeconds / 60);
                const seconds = elapsedSeconds % 60;
                const stopwatchEl = document.getElementById('stopwatch');
                if (stopwatchEl) {
                    stopwatchEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        function stopStopwatch() {
            if (stopwatchInterval) {
                clearInterval(stopwatchInterval);
                stopwatchInterval = null;
            }
            return elapsedSeconds;
        }

        function updateBestTime(currentTime) {
            const bestTimeKey = 'bestTime';
            const bestTime = localStorage.getItem(bestTimeKey);
            const bestTimeNum = bestTime ? parseInt(bestTime) : null;

            if (!bestTimeNum || currentTime < bestTimeNum) {
                localStorage.setItem(bestTimeKey, currentTime.toString());
                const minutes = Math.floor(currentTime / 60);
                const seconds = currentTime % 60;
                const stopwatchEl = document.getElementById('stopwatch');
                if (stopwatchEl) {
                    stopwatchEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')} (Best!)`;
                }
            }
        }

        // Initialize
        loadNames();
    </script>
</body>
</html>
