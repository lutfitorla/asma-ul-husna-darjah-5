<!DOCTYPE html>
<html lang="ms">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kuiz Asma'ul Husna</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Amiri:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="assets/css/quiz.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>Kuiz Asma'ul Husna</h1>
            <p class="subtitle">Padankan Nama Allah dengan Maknanya</p>
        </header>

        <div class="progress-info">
            <div class="progress-text">
                <span id="currentQuestion">Soalan 1-10</span> dari 50
            </div>
            <div class="score">
                Skor: <span id="score">0</span>/<span id="totalAnswered">0</span>
            </div>
        </div>

        <div id="quizArea" class="quiz-area">
            <div class="stopwatch" id="stopwatch">0:00</div>
            <!-- Quiz questions will be loaded here -->
        </div>

        <div class="buttons">
            <button class="submit-btn" id="submitBtn">Semak Jawapan</button>
            <button class="next-btn hidden" id="nextBtn">Soalan Seterusnya</button>
            <button class="home-btn" id="homeBtn">Kembali</button>
        </div>
    </div>

    <!-- Feedback overlay -->
    <div class="feedback-backdrop" id="feedbackBackdrop"></div>
    <div class="feedback" id="feedback">
        <!-- Feedback will be shown here -->
    </div>

    <script>
        let allNames = [];
        let currentRound = 0;
        let totalScore = 0;
        let totalAnswered = 0;
        let currentQuestions = [];
        let userAnswers = {};

        // Load names from JSON
        async function loadNames() {
            try {
                const response = await fetch('data/names.json');
                const data = await response.json();
                allNames = data.names;
                startNewRound();
            } catch (error) {
                console.error('Error loading names:', error);
                alert('Error loading quiz data. Please refresh the page.');
            }
        }

        // Shuffle array
        function shuffle(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // Get random questions
        function getRandomQuestions() {
            const shuffled = shuffle(allNames);
            return shuffled.slice(0, 10);
        }

        // Start new round
        function startNewRound() {
            currentRound++;
            userAnswers = {};
            dropZoneAnswerData.clear(); // Clear stored answer data
            selectedAnswer = null; // Clear selected answer
            currentQuestions = getRandomQuestions();

            // Shuffle Arabic names but keep them paired with their translations
            const shuffledQuestions = shuffle(currentQuestions);

            renderQuiz(shuffledQuestions, []);
            updateProgress();
            startStopwatch();

            document.getElementById('submitBtn').classList.remove('hidden');
            document.getElementById('submitBtn').disabled = true;
            document.getElementById('nextBtn').classList.add('hidden');
            document.getElementById('feedback').classList.remove('show');
            document.getElementById('feedbackBackdrop').classList.remove('show');
            
            // Ensure button is disabled on start (will be enabled when all answers are filled)
            checkIfAllAnswered();
        }

        // Render quiz
        function renderQuiz(questions, meanings) {
            const quizArea = document.getElementById('quizArea');
            // Keep stopwatch, remove everything else
            const stopwatch = document.getElementById('stopwatch');
            quizArea.innerHTML = '';
            quizArea.appendChild(stopwatch);

            // Shuffle Arabic buttons (answers) independently from drop zones
            const shuffledAnswers = shuffle([...questions]);

            // Create Arabic name buttons (draggable answers) in 2×5 grid
            const arabicContainer = document.createElement('div');
            arabicContainer.className = 'arabic-names-grid';

            shuffledAnswers.forEach((question, index) => {
                const arabicBtn = document.createElement('div');
                arabicBtn.className = 'arabic-button';
                arabicBtn.textContent = question.arabic;
                arabicBtn.draggable = true;
                arabicBtn.dataset.questionId = question.id;
                arabicBtn.dataset.arabic = question.arabic;
                arabicBtn.dataset.correctMeaning = question.malay;
                arabicBtn.dataset.index = index;

                // Alternate between golden and silver styles
                if (index < 5) {
                    arabicBtn.classList.add('golden');
                } else {
                    arabicBtn.classList.add('silver');
                }

                // Drag events
                arabicBtn.addEventListener('dragstart', handleDragStart);
                arabicBtn.addEventListener('dragend', handleDragEnd);

                // Touch events for mobile
                arabicBtn.addEventListener('touchstart', handleTouchStart);
                arabicBtn.addEventListener('touchcancel', handleTouchCancel);
                
                // Click to select
                arabicBtn.addEventListener('click', handleAnswerClick);

                arabicContainer.appendChild(arabicBtn);
            });

            quizArea.appendChild(arabicContainer);

            // Shuffle drop zones (questions) independently from answers
            const shuffledQuestions = shuffle([...questions]);

            // Create translation items (static questions) with drop zones
            const translationsContainer = document.createElement('div');
            translationsContainer.className = 'translations-container';

            // Create two columns
            const leftColumn = document.createElement('div');
            leftColumn.className = 'translation-column';
            const rightColumn = document.createElement('div');
            rightColumn.className = 'translation-column';

            shuffledQuestions.forEach((question, index) => {
                const translationItem = document.createElement('div');
                translationItem.className = 'translation-item';

                // Drop zone on the left
                const dropZone = document.createElement('div');
                dropZone.className = 'drop-zone';
                dropZone.dataset.questionId = question.id;
                dropZone.dataset.correctArabic = question.arabic;
                dropZone.dataset.correctMeaning = question.malay;
                dropZone.dataset.index = index;
                dropZone.textContent = ''; // Empty initially

                // Translation text on the right (remove "Yang" prefix)
                const translationText = document.createElement('div');
                translationText.className = 'translation-text';
                const malayText = question.malay.startsWith('Yang ') 
                    ? question.malay.substring(5) 
                    : question.malay;
                translationText.textContent = malayText;

                // Drop zone events
                dropZone.addEventListener('dragover', handleDragOver);
                dropZone.addEventListener('dragleave', handleDragLeave);
                dropZone.addEventListener('drop', handleDrop);
                dropZone.addEventListener('touchmove', handleTouchMove);
                dropZone.addEventListener('touchend', handleTouchEnd);
                
                // Click/touch handler for undo functionality
                dropZone.addEventListener('click', handleDropZoneClick);
                
                // Track touch for undo on filled zones and place for empty zones
                let touchStartPosForDropZone = null;
                dropZone.addEventListener('touchstart', (e) => {
                    if (!touchElement || (touchElement && !touchElement.classList.contains('dragging'))) {
                        touchStartPosForDropZone = {
                            x: e.touches[0].clientX,
                            y: e.touches[0].clientY,
                            time: Date.now()
                        };
                    }
                }, {passive: true});
                
                dropZone.addEventListener('touchend', (e) => {
                    if (touchStartPosForDropZone && 
                        (!touchElement || (touchElement && !touchElement.classList.contains('dragging'))) &&
                        !draggedElement) {
                        const touch = e.changedTouches[0];
                        const deltaX = Math.abs(touch.clientX - touchStartPosForDropZone.x);
                        const deltaY = Math.abs(touch.clientY - touchStartPosForDropZone.y);
                        const deltaTime = Date.now() - touchStartPosForDropZone.time;
                        
                        // Only handle if it was a tap (minimal movement, quick tap)
                        if (deltaX < 10 && deltaY < 10 && deltaTime < 300) {
                            e.preventDefault();
                            
                            // If there's a selected answer, place it
                            if (selectedAnswer) {
                                placeSelectedAnswer(dropZone);
                            }
                            // If drop zone is filled and no selection, undo it
                            else if (dropZone.classList.contains('filled')) {
                                performUndo(dropZone);
                            }
                        }
                        touchStartPosForDropZone = null;
                    }
                }, {passive: false});

                translationItem.appendChild(dropZone);
                translationItem.appendChild(translationText);

                // Distribute to columns (first 5 in left, last 5 in right)
                if (index < 5) {
                    leftColumn.appendChild(translationItem);
                } else {
                    rightColumn.appendChild(translationItem);
                }
            });

            translationsContainer.appendChild(leftColumn);
            translationsContainer.appendChild(rightColumn);
            quizArea.appendChild(translationsContainer);
        }

        // Drag and drop handlers
        let draggedElement = null;
        let touchElement = null;
        let touchStartPos = {};
        let selectedAnswer = null; // For click-to-select functionality
        
        // Store references to drop zones and their answer element data
        let dropZoneAnswerData = new Map();

        function handleDragStart(e) {
            draggedElement = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', e.target.dataset.questionId);
            e.dataTransfer.setData('arabic', e.target.dataset.arabic);
            // Clear any selected answer when starting to drag
            if (selectedAnswer) {
                selectedAnswer.classList.remove('selected');
                selectedAnswer = null;
            }
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            e.target.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.target.classList.remove('drag-over');
        }

        // Helper function to restore an answer element to the grid
        function restoreAnswerToGrid(answerData) {
            const arabicContainer = document.querySelector('.arabic-names-grid');
            if (!arabicContainer) return;

            const arabicBtn = document.createElement('div');
            arabicBtn.className = 'arabic-button';
            arabicBtn.textContent = answerData.arabic;
            arabicBtn.draggable = true;
            arabicBtn.dataset.questionId = answerData.questionId;
            arabicBtn.dataset.arabic = answerData.arabic;
            arabicBtn.dataset.correctMeaning = answerData.correctMeaning;
            arabicBtn.dataset.index = answerData.index;

            // Apply the original style (golden or silver)
            if (answerData.index < 5) {
                arabicBtn.classList.add('golden');
            } else {
                arabicBtn.classList.add('silver');
            }

            // Reattach event listeners
            arabicBtn.addEventListener('dragstart', handleDragStart);
            arabicBtn.addEventListener('dragend', handleDragEnd);
            arabicBtn.addEventListener('touchstart', handleTouchStart);
            arabicBtn.addEventListener('touchcancel', handleTouchCancel);
            arabicBtn.addEventListener('click', handleAnswerClick);

            // Add to grid (append to end)
            arabicContainer.appendChild(arabicBtn);
        }

        // Helper function to store answer data in drop zone
        function storeAnswerInDropZone(dropZone, answerElement) {
            const answerData = {
                questionId: answerElement.dataset.questionId,
                arabic: answerElement.dataset.arabic,
                correctMeaning: answerElement.dataset.correctMeaning,
                index: answerElement.dataset.index
            };
            dropZoneAnswerData.set(dropZone, answerData);
        }

        // Helper function to return old answer from drop zone
        function returnOldAnswerFromDropZone(dropZone) {
            if (dropZone.classList.contains('filled') && dropZoneAnswerData.has(dropZone)) {
                const answerData = dropZoneAnswerData.get(dropZone);
                restoreAnswerToGrid(answerData);
                dropZoneAnswerData.delete(dropZone);
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drag-over');

            const draggedQuestionId = e.dataTransfer.getData('text/plain');
            const draggedArabic = e.dataTransfer.getData('arabic');
            const dropZoneQuestionId = e.target.dataset.questionId;

            if (e.target.classList.contains('drop-zone')) {
                const dropZone = e.target;
                
                // If drop zone is already filled, return the old answer first
                if (dropZone.classList.contains('filled')) {
                    returnOldAnswerFromDropZone(dropZone);
                    // Remove old user answer
                    delete userAnswers[dropZoneQuestionId];
                }

                // Display the transliteration or Arabic name in the drop zone
                const draggedBtn = draggedElement;
                const displayText = draggedBtn.textContent;
                dropZone.textContent = displayText;
                dropZone.classList.add('filled');
                dropZone.dataset.droppedArabic = draggedArabic;
                userAnswers[dropZoneQuestionId] = draggedQuestionId;

                // Store the answer data before removing the element
                if (draggedElement) {
                    storeAnswerInDropZone(dropZone, draggedElement);
                    draggedElement.remove();
                    draggedElement = null;
                }

                checkIfAllAnswered();
            }
        }

        // Handle click on Arabic button to select it
        function handleAnswerClick(e) {
            const target = e.target || e;
            
            // Don't handle if actively dragging (but allow if touchElement exists but not dragging)
            if (draggedElement || (touchElement && touchElement.classList.contains('dragging'))) {
                return;
            }
            
            // Prevent default to avoid conflicts
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            // If clicking the same selected answer, deselect it
            if (selectedAnswer === target) {
                selectedAnswer.classList.remove('selected');
                selectedAnswer = null;
                return;
            }
            
            // Clear previous selection
            const prevSelected = document.querySelector('.arabic-button.selected');
            if (prevSelected) {
                prevSelected.classList.remove('selected');
            }
            
            // Select this answer
            selectedAnswer = target;
            selectedAnswer.classList.add('selected');
        }

        // Handle click on drop zone to place selected answer or undo
        function handleDropZoneClick(e) {
            const dropZone = e.target;
            
            if (!dropZone.classList.contains('drop-zone')) {
                return;
            }
            
            // Don't trigger if user is actively dragging something
            if (draggedElement || (touchElement && touchElement.classList.contains('dragging'))) {
                return;
            }
            
            // If there's a selected answer, place it
            if (selectedAnswer) {
                placeSelectedAnswer(dropZone);
                return;
            }
            
            // If drop zone is filled and no selection, undo it
            if (dropZone.classList.contains('filled')) {
                performUndo(dropZone);
            }
        }
        
        // Place selected answer into drop zone
        function placeSelectedAnswer(dropZone) {
            if (!selectedAnswer) return;
            
            const dropZoneQuestionId = dropZone.dataset.questionId;
            const selectedQuestionId = selectedAnswer.dataset.questionId;
            const selectedArabic = selectedAnswer.dataset.arabic;
            
            // If drop zone is already filled, return the old answer first
            if (dropZone.classList.contains('filled')) {
                returnOldAnswerFromDropZone(dropZone);
                delete userAnswers[dropZoneQuestionId];
            }
            
            // Place the selected answer
            dropZone.textContent = selectedAnswer.textContent;
            dropZone.classList.add('filled');
            dropZone.dataset.droppedArabic = selectedArabic;
            userAnswers[dropZoneQuestionId] = selectedQuestionId;
            
            // Store the answer data
            storeAnswerInDropZone(dropZone, selectedAnswer);
            
            // Remove the selected answer from grid
            selectedAnswer.remove();
            selectedAnswer = null;
            
            checkIfAllAnswered();
        }
        
        function performUndo(dropZone) {
            // Return the answer to available choices
            returnOldAnswerFromDropZone(dropZone);
            
            // Clear the drop zone
            dropZone.textContent = '';
            dropZone.classList.remove('filled');
            dropZone.classList.remove('drag-over');
            delete dropZone.dataset.droppedArabic;
            
            // Remove from user answers
            const questionId = dropZone.dataset.questionId;
            delete userAnswers[questionId];
            
            checkIfAllAnswered();
        }

        // Touch handlers for mobile
        function handleTouchStart(e) {
            // If there's already a touch in progress, reset it first
            if (touchElement && touchElement !== e.target) {
                // Reset previous touch element
                touchElement.style.position = '';
                touchElement.style.zIndex = '';
                touchElement.style.left = '';
                touchElement.style.top = '';
                touchElement.classList.remove('dragging');
            }

            // Only allow dragging answer boxes, not drop zones
            if (!e.target.classList.contains('arabic-button')) {
                return;
            }

            // Don't start drag immediately - wait to see if user moves finger
            // This allows tap-to-select to work on mobile
            touchElement = e.target;

            const touch = e.touches[0];
            touchStartPos = {
                x: touch.clientX,
                y: touch.clientY,
                elementX: touchElement.offsetLeft,
                elementY: touchElement.offsetTop,
                time: Date.now()
            };
            
            // Don't prevent default yet - let tap events work
        }

        function handleTouchMove(e) {
            if (!touchElement) return;
            
            const touch = e.touches[0];
            const deltaX = Math.abs(touch.clientX - touchStartPos.x);
            const deltaY = Math.abs(touch.clientY - touchStartPos.y);
            
            // Only start dragging if user has moved finger significantly (more than 10px)
            // This allows tap-to-select for small movements
            if (deltaX < 10 && deltaY < 10) {
                return; // Too small movement, treat as tap
            }
            
            e.preventDefault();

            // Clear any selected answer when starting to drag
            if (selectedAnswer) {
                selectedAnswer.classList.remove('selected');
                selectedAnswer = null;
            }
            
            // Now start the drag behavior
            touchElement.classList.add('dragging');
            touchElement.style.position = 'fixed';
            touchElement.style.zIndex = '1000';
            touchElement.style.left = touch.clientX - 50 + 'px';
            touchElement.style.top = touch.clientY - 25 + 'px';

            // Highlight drop zone (can highlight filled zones too for replacement)
            const dropZones = document.querySelectorAll('.drop-zone');
            dropZones.forEach(zone => {
                const rect = zone.getBoundingClientRect();
                if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                    touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
                    zone.classList.add('drag-over');
                } else {
                    zone.classList.remove('drag-over');
                }
            });
        }

        function handleTouchCancel(e) {
            // Reset touch element if touch is cancelled
            if (touchElement) {
                touchElement.style.position = '';
                touchElement.style.zIndex = '';
                touchElement.style.left = '';
                touchElement.style.top = '';
                touchElement.classList.remove('dragging');
                
                // Clean up drag-over classes
                const dropZones = document.querySelectorAll('.drop-zone');
                dropZones.forEach(zone => {
                    zone.classList.remove('drag-over');
                });
                
                touchElement = null;
            }
        }

        function handleTouchEnd(e) {
            if (!touchElement) return;

            const touch = e.changedTouches[0];
            const deltaX = Math.abs(touch.clientX - touchStartPos.x);
            const deltaY = Math.abs(touch.clientY - touchStartPos.y);
            const deltaTime = Date.now() - touchStartPos.time;
            
            // If it was a tap (minimal movement, quick tap), treat as click for selection
            if (deltaX < 10 && deltaY < 10 && deltaTime < 300) {
                // Handle as tap-to-select instead of drag
                if (!touchElement.classList.contains('dragging')) {
                    // Trigger click handler for selection
                    handleAnswerClick({ target: touchElement, stopPropagation: () => {}, preventDefault: () => {} });
                    touchElement = null;
                    return;
                }
            }
            
            // If we were dragging, handle drop
            if (!touchElement.classList.contains('dragging')) {
                touchElement = null;
                return;
            }

            const dropZones = document.querySelectorAll('.drop-zone');

            let dropped = false;
            
            // Find the drop zone under the touch point
            for (const zone of dropZones) {
                const rect = zone.getBoundingClientRect();
                if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                    touch.clientY >= rect.top && touch.clientY <= rect.bottom) {

                    const draggedQuestionId = touchElement.dataset.questionId;
                    const draggedArabic = touchElement.dataset.arabic;
                    const displayText = touchElement.textContent;
                    const questionId = zone.dataset.questionId;

                    // Only drop if we haven't already dropped this element
                    if (!dropped) {
                        // If drop zone is already filled, return the old answer first
                        if (zone.classList.contains('filled')) {
                            returnOldAnswerFromDropZone(zone);
                            // Remove old user answer
                            delete userAnswers[questionId];
                        }

                        zone.textContent = displayText;
                        zone.classList.add('filled');
                        zone.classList.remove('drag-over');
                        zone.dataset.droppedArabic = draggedArabic;
                        userAnswers[questionId] = draggedQuestionId;

                        // Store the answer data before removing the element
                        storeAnswerInDropZone(zone, touchElement);
                        touchElement.remove();
                        dropped = true;
                    }
                    break; // Exit loop once we've found and handled the drop zone
                }
            }

            if (!dropped && touchElement) {
                // Reset position
                touchElement.style.position = '';
                touchElement.style.zIndex = '';
                touchElement.style.left = '';
                touchElement.style.top = '';
                touchElement.classList.remove('dragging');
            }

            // Clean up: remove drag-over class from all zones
            dropZones.forEach(zone => {
                zone.classList.remove('drag-over');
            });

            touchElement = null;
            checkIfAllAnswered();
        }

        // Check if all questions are answered
        function checkIfAllAnswered() {
            const submitBtn = document.getElementById('submitBtn');
            submitBtn.disabled = Object.keys(userAnswers).length !== currentQuestions.length;
        }

        // Submit answers
        function submitAnswers() {
            // Stop stopwatch and record time
            const elapsedTime = stopStopwatch();
            if (elapsedTime) {
                updateBestTime(elapsedTime);
            }

            let correctCount = 0;
            const feedbackDiv = document.getElementById('feedback');
            feedbackDiv.innerHTML = `
                <div class="feedback-header">
                    <h2>Keputusan</h2>
                    <button class="feedback-close" id="feedbackClose" aria-label="Close">×</button>
                </div>
                <div class="feedback-content">
                    <div class="feedback-column"></div>
                    <div class="feedback-column"></div>
                </div>
            `;
            const feedbackContent = feedbackDiv.querySelector('.feedback-content');
            const leftColumn = feedbackContent.querySelectorAll('.feedback-column')[0];
            const rightColumn = feedbackContent.querySelectorAll('.feedback-column')[1];

            currentQuestions.forEach((question, index) => {
                const userAnswerId = userAnswers[question.id];
                // Check if drop zone is actually filled before marking as correct
                const dropZone = document.querySelector(`.drop-zone[data-question-id="${question.id}"]`);
                const isFilled = dropZone && dropZone.classList.contains('filled');
                const isCorrect = isFilled && userAnswerId && userAnswerId == question.id;

                if (isCorrect) correctCount++;

                const feedbackItem = document.createElement('div');
                feedbackItem.className = `feedback-item ${isCorrect ? 'correct' : 'incorrect'}`;

                const userAnswerText = userAnswerId ? 
                    (document.querySelector(`.arabic-button[data-question-id="${userAnswerId}"]`)?.textContent || 'Tiada jawapan') 
                    : 'Tiada jawapan';

                feedbackItem.innerHTML = `
                    <div class="arabic">${question.arabic}</div>
                    <div class="answer">
                        Jawapan anda: ${userAnswerText}
                        ${!isCorrect ? `<br><span class="correct-answer">Jawapan betul: ${question.transliteration || question.arabic}</span>` : ' ✓'}
                    </div>
                `;

                // Distribute to columns (first 5 in left, last 5 in right)
                if (index < 5) {
                    leftColumn.appendChild(feedbackItem);
                } else {
                    rightColumn.appendChild(feedbackItem);
                }

                // Update drop zone styling
                const dropZones = document.querySelectorAll('.drop-zone');
                dropZones.forEach(zone => {
                    if (zone.dataset.questionId == question.id) {
                        zone.classList.add(isCorrect ? 'correct' : 'incorrect');
                        // Mark empty drop zones with red border and X
                        if (!isFilled) {
                            zone.classList.add('empty');
                            zone.innerHTML = '<span class="empty-x">✕</span>';
                        }
                    }
                });
            });

            // Lock all interactions after submission
            // Disable dragging from Arabic buttons
            const arabicButtons = document.querySelectorAll('.arabic-button');
            arabicButtons.forEach(btn => {
                btn.draggable = false;
                btn.style.pointerEvents = 'none';
                btn.style.opacity = '0.6';
                btn.style.cursor = 'not-allowed';
                // Prevent any remaining drag events
                btn.ondragstart = () => false;
            });

            // Disable all drop zone interactions
            const allDropZones = document.querySelectorAll('.drop-zone');
            allDropZones.forEach(zone => {
                zone.classList.add('locked');
                zone.style.pointerEvents = 'none';
                // Prevent any remaining drop events
                zone.ondragover = () => false;
                zone.ondrop = () => false;
                zone.onclick = () => false;
            });

            totalScore += correctCount;
            totalAnswered += currentQuestions.length;

            updateScore();
            
            // Set up close button handler
            const closeBtn = document.getElementById('feedbackClose');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeFeedback);
            }
            
            // Show feedback and backdrop
            feedbackDiv.classList.add('show');
            document.getElementById('feedbackBackdrop').classList.add('show');
            
            // Adjust positioning if modal is taller than viewport
            setTimeout(() => {
                const feedback = document.getElementById('feedback');
                const viewportHeight = window.innerHeight;
                const modalHeight = feedback.offsetHeight;
                
                if (modalHeight > viewportHeight - 40) {
                    // Modal is too tall, position at top and allow page scroll
                    feedback.style.top = '20px';
                    feedback.style.transform = 'translateX(-50%)';
                } else {
                    // Modal fits, center it vertically
                    feedback.style.top = '50%';
                    feedback.style.transform = 'translate(-50%, -50%)';
                }
            }, 50);

            document.getElementById('submitBtn').classList.add('hidden');
            document.getElementById('nextBtn').classList.remove('hidden');
        }

        // Update progress
        function updateProgress() {
            const start = (currentRound - 1) * 10 + 1;
            const end = Math.min(currentRound * 10, totalAnswered + 10);
            document.getElementById('currentQuestion').textContent = `Soalan ${start}-${end}`;
        }

        // Update score
        function updateScore() {
            document.getElementById('score').textContent = totalScore;
            document.getElementById('totalAnswered').textContent = totalAnswered;
        }

        // Event listeners
        document.getElementById('submitBtn').addEventListener('click', submitAnswers);
        document.getElementById('nextBtn').addEventListener('click', startNewRound);
        document.getElementById('homeBtn').addEventListener('click', () => {
            window.location.href = 'index.html';
        });
        
        // Close feedback function
        function closeFeedback() {
            document.getElementById('feedback').classList.remove('show');
            document.getElementById('feedbackBackdrop').classList.remove('show');
        }
        
        // Close feedback when clicking backdrop (but not when clicking inside the modal)
        document.getElementById('feedbackBackdrop').addEventListener('click', (e) => {
            if (e.target.id === 'feedbackBackdrop') {
                closeFeedback();
            }
        });
        
        // Prevent clicks inside feedback modal from closing it
        document.getElementById('feedback').addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // Close feedback when clicking close button (set up after feedback is created)
        document.addEventListener('click', (e) => {
            if (e.target.id === 'feedbackClose' || e.target.classList.contains('feedback-close')) {
                closeFeedback();
            }
        });
        
        // Adjust feedback positioning on window resize
        function adjustFeedbackPosition() {
            const feedback = document.getElementById('feedback');
            if (feedback && feedback.classList.contains('show')) {
                const viewportHeight = window.innerHeight;
                const modalHeight = feedback.offsetHeight;
                
                if (modalHeight > viewportHeight - 40) {
                    // Modal is too tall, position at top and allow page scroll
                    feedback.style.top = '20px';
                    feedback.style.transform = 'translateX(-50%)';
                } else {
                    // Modal fits, center it vertically
                    feedback.style.top = '50%';
                    feedback.style.transform = 'translate(-50%, -50%)';
                }
            }
        }
        
        // Listen for window resize events
        window.addEventListener('resize', adjustFeedbackPosition);

        // Stopwatch functionality
        let stopwatchInterval = null;
        let startTime = null;
        let elapsedSeconds = 0;

        function startStopwatch() {
            startTime = Date.now();
            elapsedSeconds = 0;
            const stopwatchEl = document.getElementById('stopwatch');
            if (stopwatchEl) stopwatchEl.textContent = '0:00';

            if (stopwatchInterval) clearInterval(stopwatchInterval);

            stopwatchInterval = setInterval(() => {
                elapsedSeconds++;
                const minutes = Math.floor(elapsedSeconds / 60);
                const seconds = elapsedSeconds % 60;
                const stopwatchEl = document.getElementById('stopwatch');
                if (stopwatchEl) {
                    stopwatchEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        function stopStopwatch() {
            if (stopwatchInterval) {
                clearInterval(stopwatchInterval);
                stopwatchInterval = null;
            }
            return elapsedSeconds;
        }

        function updateBestTime(currentTime) {
            const bestTimeKey = 'bestTime';
            const bestTime = localStorage.getItem(bestTimeKey);
            const bestTimeNum = bestTime ? parseInt(bestTime) : null;

            if (!bestTimeNum || currentTime < bestTimeNum) {
                localStorage.setItem(bestTimeKey, currentTime.toString());
                const minutes = Math.floor(currentTime / 60);
                const seconds = currentTime % 60;
                const stopwatchEl = document.getElementById('stopwatch');
                if (stopwatchEl) {
                    stopwatchEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')} (Best!)`;
                }
            }
        }

        // Initialize
        loadNames();
    </script>
</body>
</html>
